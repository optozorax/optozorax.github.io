<!DOCTYPE html>
<html lang="ru">

<head>
  
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript" > (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(53392057, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true, webvisor:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/53392057" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
  <meta name="yandex-verification" content="ec61b5ac4464201b" />
  <!-- --- -->
  

  <!-- Non social metatags -->
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="canonical" href="https://optozorax.github.io/">
  <meta name="robots" content="noarchive">
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml"> 
  <!-- --- -->

  <!-- Fonts preload -->
  <link rel="preload" as="font" href="/fonts/Rubik/iJWKBXyIfDnIV7nFrXyi0A.woff2" crossOrigin="anonymous">
  <link rel="preload" as="font" href="/fonts/Rubik/iJWKBXyIfDnIV7nBrXw.woff2" crossOrigin="anonymous">
  <link rel="preload" as="font" href="/fonts/JetBrainsMono/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxDcwg.woff2" crossOrigin="anonymous">
  <link rel="preload" as="font" href="/fonts/JetBrainsMono/tDbv2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKwBNntkaToggR7BYRbKPxTcwhsk.woff2" crossOrigin="anonymous">
  <!-- --- -->

  <!-- Social metatags -->
  
<meta name="author" content="optozorax">
<meta name="title" content="Применения std::function — Блог optozorax&#x27;а">
<meta name="description" content="Рассказываю как улучшить качество кода при помощи типа данных функций и лямбда-функций.">
<meta name="image" content="preview.png">

<meta name="keywords" itemprop="tags" content="программирование, c++">


<!-- Facebook Meta Tags -->
<meta property="og:url" content="https://optozorax.github.io/p/std-function/">
<meta property="og:type" content="article">
<meta property="og:title" content="Применения std::function — Блог optozorax&#x27;а">
<meta property="og:description" content="Рассказываю как улучшить качество кода при помощи типа данных функций и лямбда-функций.">
<meta property="og:image" content="preview.png">
<meta property="og:locale" content="ru">


<meta property="article:published_time" content="2019-01-30">




<meta property="article:tag" content="программирование">

<meta property="article:tag" content="c++">



<!-- Twitter Meta Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta property="twitter:domain" content="optozorax.github.io">
<meta property="twitter:url" content="https://optozorax.github.io/p/std-function/">
<meta name="twitter:title" content="Применения std::function — Блог optozorax&#x27;а">
<meta name="twitter:description" content="Рассказываю как улучшить качество кода при помощи типа данных функций и лямбда-функций.">
<meta name="twitter:image" content="preview.png">
<meta name="twitter:creator" content="optozorax">

  <!-- --- -->

  <!-- Extra head declarations -->
  

<script type="text/javascript" src="/js/hammer.min.js"></script>
<script type="text/javascript" src="/js/toc.js"></script>
<script type="text/javascript" src="/js/gallery.js"></script>
<script type="text/javascript" src="/js/full_screen.js"></script>
<script type="text/javascript" src="/js/word_wrap.js"></script>

  <!-- --- -->

  <!-- CSS -->
  <link rel="stylesheet" href="/main.css">
  <!-- --- -->

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="shortcut icon" href="/favicon/favicon.ico">
  <link rel="manifest" href="/favicon/site.webmanifest">
  <link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="msapplication-config" content="/favicon/browserconfig.xml" />
  <!-- --- -->

  <title>Применения std::function — Блог optozorax&#x27;а</title>
</head>

<body>
  <!-- FullScreen block -->
  <div id="img_modal" class="modal" style="display: none;">
      <img id="img_modal_01" src="/ico/loading.gif">
      <span class="close" id="img_modal_close">&times;</span>
  </div>
  <!-- --- -->

  

<table class="toc-aligmenter"><tr><td>


  <header class="site-header" role="banner">
  
  <div class="wrapper">
    <a class="site-title" href="/">optozorax.blog</a>

    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <img src="/ico/menu.svg" width="13px" height="15px">
        </span>
      </label>

      <div class="trigger">
        
          <a class="page-link" href="/">Блог</a>
        
          <a class="page-link" href="/e">Систематизация</a>
        
          <a class="page-link" href="/tags">Теги</a>
        
          <a class="page-link" href="/about">Обо мне</a>
        
      </div>
    </nav>
  </div>
  
  </header>
  

</td><td>
</td></tr></table>



  
  
  <section class="page-header">
  

<table class="toc-aligmenter"><tr><td>


<h1 class="project-name">Применения std::function</h1>

<h2 class="project-tagline">Рассказываю как улучшить качество кода при помощи типа данных функций и лямбда-функций.</h2>



<span style="margin-bottom: 10px;">
  
    <a href="/tags#programmirovanie"><code class="tag"><nobr>#программирование</nobr></code></a>&nbsp;
  
    <a href="/tags#c"><code class="tag"><nobr>#c++</nobr></code></a>&nbsp;
  
</span>


<center>
<table style="margin-top: 8px;">
<tr>


<td style="padding-right: 10px; border-right: 0px solid #ffffff;">
<h2 class="project-date" style="margin-top: 0px;">
  <time datetime="2019-01-30" itemprop="datePublished">
    
    
    
    
    <span class="post-date">30 января 2019</span>
  </time>
</h2>
</td>



</tr>
</table>


</center>


</td><td>
</td></tr></table>



  </section>
  
  

  

<table class="toc-aligmenter"><tr><td>


  <section class="main-content section">
  
<article itemscope itemtype="http://schema.org/BlogPosting">
<div itemprop="articleBody" id="content">
<h1 id="stat-ia-ob-ispol-zovanii-std-function"><a class="anchor" href="#stat-ia-ob-ispol-zovanii-std-function">#</a>Статья об использовании std::function</h1>
<p>Поводом для написания данной статьи стало желание систематизировать всё то, чему я научился в процессе кодинга лаб по таким предметам, как <a href="https://github.com/optozorax/numerical_methods">Численные методы</a>; <a href="https://github.com/optozorax/labs_emf">Уравнения математической физики</a>; <a href="https://github.com/optozorax/optimization_methods">Методы оптимизации</a>. Надеюсь эта статья будет полезна не только людям, которые учатся в НГТУ на факультете ФПМИ, но и широкому кругу читателей.</p>
<h1 id="vvedenie"><a class="anchor" href="#vvedenie">#</a>Введение</h1>
<p>В Си/C++ имеется возможность передавать функцию в качестве аргумента функции как указатель на функцию. Вы наверняка знаете этот страшный синтаксис:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">int </span><span style="color:#c23f31;">add</span><span>(</span><span style="color:#668f14;">int </span><span style="color:#5597d6;">x</span><span>, </span><span style="color:#668f14;">int </span><span style="color:#5597d6;">y</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return</span><span> x</span><span style="color:#72ab00;">+</span><span>y;
</span><span>}
</span><span>
</span><span style="color:#668f14;">void </span><span style="color:#c23f31;">call_operation</span><span>(</span><span style="color:#668f14;">int </span><span>(</span><span style="color:#72ab00;">*</span><span>operation)(</span><span style="color:#668f14;">int</span><span>, </span><span style="color:#668f14;">int</span><span>)) {
</span><span>	</span><span style="color:#668f14;">int</span><span> c </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">operation</span><span>(</span><span style="color:#b3933a;">1</span><span>, </span><span style="color:#b3933a;">2</span><span>);
</span><span>}
</span><span>
</span><span style="color:#5597d6;">call_operation</span><span>(add);
</span></code></pre>
<p>Начиная с C++11 появился удобный интерфейс для описания функциональных объектов под названием <code>std::function</code>, он имеет более красивый синтаксис:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#72ab00;">#include </span><span style="color:#d07711;">&lt;functional&gt;
</span><span>
</span><span style="color:#668f14;">int </span><span style="color:#c23f31;">add</span><span>(</span><span style="color:#668f14;">int </span><span style="color:#5597d6;">x</span><span>, </span><span style="color:#668f14;">int </span><span style="color:#5597d6;">y</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return</span><span> x</span><span style="color:#72ab00;">+</span><span>y;
</span><span>}
</span><span>
</span><span style="color:#668f14;">int </span><span style="color:#c23f31;">call_operation</span><span>(std::function&lt;</span><span style="color:#668f14;">int</span><span>(</span><span style="color:#668f14;">int</span><span>, </span><span style="color:#668f14;">int</span><span>)&gt; </span><span style="color:#5597d6;">operation</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return </span><span style="color:#5597d6;">operation</span><span>(</span><span style="color:#b3933a;">1</span><span>, </span><span style="color:#b3933a;">2</span><span>);
</span><span>}
</span><span>
</span><span style="color:#668f14;">int</span><span> c </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">call_operation</span><span>(add); </span><span style="color:#7f8989;">// c = 3
</span></code></pre>
<p>Причём, в отличие от Си, в C++ таким образом можно описывать любой функциональный объект, то есть объект, допускающий вызов операции <code>()</code>:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#7f8989;">// ...
</span><span>
</span><span style="color:#668f14;">struct </span><span style="color:#c23f31;">Adder
</span><span>{
</span><span>	</span><span style="color:#668f14;">int </span><span style="color:#c23f31;">operator()</span><span>(</span><span style="color:#668f14;">int </span><span style="color:#5597d6;">a</span><span>, </span><span style="color:#668f14;">int </span><span style="color:#5597d6;">b</span><span>) {
</span><span>		</span><span style="color:#72ab00;">return</span><span> state </span><span style="color:#72ab00;">+</span><span> a </span><span style="color:#72ab00;">+</span><span> b;
</span><span>	}
</span><span>	
</span><span>	</span><span style="color:#668f14;">int</span><span> state;
</span><span>};
</span><span>
</span><span>Adder add </span><span style="color:#72ab00;">= </span><span>{</span><span style="color:#b3933a;">1</span><span>};
</span><span>
</span><span style="color:#668f14;">int</span><span> d </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">call_operation</span><span>(add); </span><span style="color:#7f8989;">// d = 4
</span></code></pre>
<p>Аналогичным образом можно использовать <a href="https://habr.com/ru/post/66021/">лямбды</a>:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#7f8989;">// ...
</span><span>
</span><span style="color:#668f14;">int</span><span> state </span><span style="color:#72ab00;">= </span><span style="color:#b3933a;">2</span><span>;
</span><span>
</span><span style="color:#668f14;">int</span><span> e </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">call_operation</span><span>([</span><span style="color:#72ab00;">&amp;</span><span>](</span><span style="color:#668f14;">int</span><span> a, </span><span style="color:#668f14;">int</span><span> b) -&gt; </span><span style="color:#5597d6;">int </span><span>{
</span><span>	</span><span style="color:#72ab00;">return</span><span> state </span><span style="color:#72ab00;">+</span><span> a </span><span style="color:#72ab00;">+</span><span> b;
</span><span>}); </span><span style="color:#7f8989;">// e = 5
</span></code></pre>
<p>Таким образом, можно передавать функции в качестве аргументов функций.</p>
<h1 id="chislennoe-vychislenie-proizvodnoi"><a class="anchor" href="#chislennoe-vychislenie-proizvodnoi">#</a>Численное вычисление производной</h1>
<p>Пусть у нас имеется некоторая функция <code>f</code>, которая получает <code>double</code> и возвращает <code>double</code>. Тогда можно численно вычислить производную этой функции следующим образом:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">double </span><span style="color:#c23f31;">f</span><span>(</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">x</span><span>);
</span><span>
</span><span style="color:#668f14;">double </span><span style="color:#c23f31;">derivative_f</span><span>(</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">x</span><span>) {
</span><span>	</span><span style="color:#668f14;">double</span><span> h </span><span style="color:#72ab00;">= </span><span style="color:#b3933a;">0.0001</span><span>;
</span><span>	</span><span style="color:#72ab00;">return </span><span>(</span><span style="color:#5597d6;">f</span><span>(x</span><span style="color:#72ab00;">+</span><span>h)</span><span style="color:#72ab00;">-</span><span style="color:#5597d6;">f</span><span>(x))</span><span style="color:#72ab00;">/</span><span>h;
</span><span>}
</span></code></pre>
<p>Но писать для каждой функции другую функцию, вычисляющую её производную непрактично! Поэтому такую проблему можно решить с помощью <code>std::function</code>:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">double</span><span>)&gt; </span><span style="color:#c23f31;">derivative</span><span>(std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">double</span><span>)&gt; </span><span style="color:#5597d6;">f</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return </span><span>[f] (</span><span style="color:#668f14;">double</span><span> x) -&gt; </span><span style="color:#5597d6;">double </span><span>{
</span><span>		</span><span style="color:#668f14;">double</span><span> h </span><span style="color:#72ab00;">= </span><span style="color:#b3933a;">0.0001</span><span>;
</span><span>		</span><span style="color:#72ab00;">return </span><span>(</span><span style="color:#5597d6;">f</span><span>(x</span><span style="color:#72ab00;">+</span><span>h)</span><span style="color:#72ab00;">-</span><span style="color:#5597d6;">f</span><span>(x))</span><span style="color:#72ab00;">/</span><span>h;
</span><span>	}
</span><span>}
</span></code></pre>
<p>Данная функция получает функцию, и возвращает функцию, которая считает её производную. Пример использования:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">double </span><span style="color:#c23f31;">f</span><span>(</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">x</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return</span><span> x</span><span style="color:#72ab00;">*</span><span>x;
</span><span>}
</span><span>
</span><span style="color:#668f14;">auto</span><span> df </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">derivative</span><span>(f);
</span><span>
</span><span style="color:#668f14;">double</span><span> a </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">f</span><span>(</span><span style="color:#b3933a;">1</span><span>); </span><span style="color:#7f8989;">// a == 1
</span><span style="color:#668f14;">double</span><span> a </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">df</span><span>(</span><span style="color:#b3933a;">1</span><span>); </span><span style="color:#7f8989;">// a == 2
</span></code></pre>
<p>А далее представлен код для вычисления первой и второй производных функций, взятый из <a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/fem.cpp#L283">курсовой по УМФ</a>, смело используйте его в своих проектах.</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">typedef</span><span> std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">double</span><span>)&gt; </span><span style="color:#c23f31;">function_1d_t</span><span>; 
</span><span>
</span><span>function_1d_t </span><span style="color:#c23f31;">calc_first_derivative</span><span>(</span><span style="color:#668f14;">const</span><span> function_1d_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return </span><span>[f](</span><span style="color:#668f14;">double</span><span> x) -&gt; </span><span style="color:#5597d6;">double </span><span>{
</span><span>		</span><span style="color:#668f14;">const double</span><span> h </span><span style="color:#72ab00;">= </span><span style="color:#b3933a;">0.001</span><span>;
</span><span>		</span><span style="color:#72ab00;">return </span><span>(</span><span style="color:#72ab00;">-</span><span style="color:#5597d6;">f</span><span>(x </span><span style="color:#72ab00;">+ </span><span style="color:#b3933a;">2 </span><span style="color:#72ab00;">*</span><span> h) </span><span style="color:#72ab00;">+ </span><span style="color:#b3933a;">8 </span><span style="color:#72ab00;">* </span><span style="color:#5597d6;">f</span><span>(x </span><span style="color:#72ab00;">+</span><span> h) </span><span style="color:#72ab00;">- </span><span style="color:#b3933a;">8 </span><span style="color:#72ab00;">* </span><span style="color:#5597d6;">f</span><span>(x </span><span style="color:#72ab00;">-</span><span> h) </span><span style="color:#72ab00;">+ </span><span style="color:#5597d6;">f</span><span>(x </span><span style="color:#72ab00;">- </span><span style="color:#b3933a;">2 </span><span style="color:#72ab00;">*</span><span> h)) </span><span style="color:#72ab00;">/ </span><span>(</span><span style="color:#b3933a;">12 </span><span style="color:#72ab00;">*</span><span> h);
</span><span>	};
</span><span>}
</span><span>
</span><span>function_1d_t </span><span style="color:#c23f31;">calc_second_derivative</span><span>(</span><span style="color:#668f14;">const</span><span> function_1d_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return </span><span>[f](</span><span style="color:#668f14;">double</span><span> x) -&gt; </span><span style="color:#5597d6;">double </span><span>{
</span><span>		</span><span style="color:#668f14;">const double</span><span> h </span><span style="color:#72ab00;">= </span><span style="color:#b3933a;">0.001</span><span>;
</span><span>		</span><span style="color:#72ab00;">return </span><span>(</span><span style="color:#72ab00;">-</span><span style="color:#5597d6;">f</span><span>(x</span><span style="color:#72ab00;">+</span><span style="color:#b3933a;">2</span><span style="color:#72ab00;">*</span><span>h) </span><span style="color:#72ab00;">+ </span><span style="color:#b3933a;">16</span><span style="color:#72ab00;">*</span><span style="color:#5597d6;">f</span><span>(x</span><span style="color:#72ab00;">+</span><span>h) </span><span style="color:#72ab00;">- </span><span style="color:#b3933a;">30</span><span style="color:#72ab00;">*</span><span style="color:#5597d6;">f</span><span>(x) </span><span style="color:#72ab00;">+ </span><span style="color:#b3933a;">16</span><span style="color:#72ab00;">*</span><span style="color:#5597d6;">f</span><span>(x</span><span style="color:#72ab00;">-</span><span>h) </span><span style="color:#72ab00;">- </span><span style="color:#5597d6;">f</span><span>(x</span><span style="color:#72ab00;">-</span><span style="color:#b3933a;">2</span><span style="color:#72ab00;">*</span><span>h))</span><span style="color:#72ab00;">/</span><span>(</span><span style="color:#b3933a;">12</span><span style="color:#72ab00;">*</span><span>h</span><span style="color:#72ab00;">*</span><span>h);
</span><span>	};
</span><span>}
</span></code></pre>
<p>Может показаться, что если уменьшить величину <code>0.001</code>, то точность повысится, но это не так, на практике у меня точность только падала, а при этом значении уже очень хорошо расчитывается производная.</p>
<h1 id="primer-ispol-zovaniia-std-bind"><a class="anchor" href="#primer-ispol-zovaniia-std-bind">#</a>Пример использования <code>std::bind</code></h1>
<p>Окей, у нас существует функция для расчета производной одномерной функции, но что если у нас функция принимает два аргумента, например <code>f(x, y)</code>. Как посчитать её производную по одному параметру? </p>
<p>На помощь приходит <code>std::bind</code> - функция, которая получает функцию, список аргументов и возвращает другую функцию. И лучше увидеть пример, чтобы понять как он работает:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">double </span><span style="color:#c23f31;">f</span><span>(</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">x</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">y</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return </span><span style="color:#b3933a;">2</span><span style="color:#72ab00;">*</span><span>x </span><span style="color:#72ab00;">+ </span><span style="color:#b3933a;">3</span><span style="color:#72ab00;">*</span><span>y;
</span><span>}
</span><span>
</span><span style="color:#7f8989;">// Производная f по x при y=0
</span><span style="color:#668f14;">auto</span><span> fx </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">calc_first_derivative</span><span>(std::</span><span style="color:#5597d6;">bind</span><span>(f, std::placeholders::_1, </span><span style="color:#b3933a;">0</span><span>));
</span><span>
</span><span style="color:#7f8989;">// Производная f по y при x=0
</span><span style="color:#668f14;">auto</span><span> fy </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">calc_first_derivative</span><span>(std::</span><span style="color:#5597d6;">bind</span><span>(f, </span><span style="color:#b3933a;">0</span><span>, std::placeholders::_1));
</span><span>
</span><span style="color:#668f14;">double</span><span> fx_value </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">fx</span><span>(</span><span style="color:#b3933a;">1</span><span>); </span><span style="color:#7f8989;">// fx_value = 2; 
</span><span style="color:#668f14;">double</span><span> fy_value </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">fy</span><span>(</span><span style="color:#b3933a;">1</span><span>); </span><span style="color:#7f8989;">// fy_value = 3;
</span></code></pre>
<p>Где <code>std::placeholders::_1</code> показывает первый параметр внешней функции, которую возвратит <code>std::bind</code>.</p>
<p>К сожалению в этом случае функция <code>fx</code> получается функцией одной переменной, при фиксированном <code>y=0</code>. Чтобы получить функцию <code>fx</code>, которая принимает два параметра, но при этом возвращает производную по <code>x</code>, можно воспользоваться следующим трюком:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">auto</span><span> fx </span><span style="color:#72ab00;">= </span><span>[] (</span><span style="color:#668f14;">double</span><span> x, </span><span style="color:#668f14;">double</span><span> y) -&gt; </span><span style="color:#5597d6;">double </span><span>{
</span><span>	</span><span style="color:#72ab00;">return </span><span style="color:#5597d6;">calc_first_derivative</span><span>(std::</span><span style="color:#5597d6;">bind</span><span>(f, std::placeholders::_1, y))(x);
</span><span>};
</span><span>
</span><span style="color:#668f14;">double</span><span> fx_value </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">fx</span><span>(</span><span style="color:#b3933a;">1</span><span>, </span><span style="color:#b3933a;">0</span><span>); </span><span style="color:#7f8989;">// df(1, 0)/dx
</span></code></pre>
<p>Наверное можно было бы его улучшить, чтобы не копипастить эти строки, и придумать новый <code>std::bind2</code>, при помощи шаблонной магии C++, но я такое не умею. Если вы сможете это сделать, обязательно pull-request'ните сюда!</p>
<p>Или другой пример:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">double </span><span style="color:#c23f31;">f</span><span>(</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">x</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">y</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">t</span><span>);
</span><span>
</span><span style="color:#72ab00;">using namespace</span><span> std::placeholders;
</span><span>
</span><span>std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">double</span><span>, </span><span style="color:#668f14;">double</span><span>)&gt; g </span><span style="color:#72ab00;">= </span><span>std::</span><span style="color:#5597d6;">bind</span><span>(f, _2, </span><span style="color:#b3933a;">5</span><span>, _1);
</span><span>
</span><span style="color:#668f14;">double</span><span> gv </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">g</span><span>(</span><span style="color:#b3933a;">1</span><span>, </span><span style="color:#b3933a;">2</span><span>);
</span><span style="color:#668f14;">double</span><span> fv </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">f</span><span>(</span><span style="color:#b3933a;">2</span><span>, </span><span style="color:#b3933a;">5</span><span>, </span><span style="color:#b3933a;">1</span><span>);
</span><span>
</span><span style="color:#7f8989;">// gv == fv
</span></code></pre>
<h1 id="avtomaticheskii-raschet-pravoi-chasti"><a class="anchor" href="#avtomaticheskii-raschet-pravoi-chasti">#</a>Автоматический расчет правой части</h1>
<p>В таком предмете, как УМФ требуется решить следующее дифференциальное уравнение: </p>
<p><code>-div(lambda * grad u) + gamma * u + sigma * du/dt = f</code>, </p>
<p>где <code>u = u(x, y, t)</code> является неизвестной функцией. Для численного решения используется Метод Конечных Элементов.</p>
<p>Для декартовых координат это уравнение раскладывается в <code>lambda*(d^2 u/dx^2 + d^2 u/dy^2)  + gamma * u + sigma * du/dt = f</code></p>
<p>Для тестирования программы-решателя мы придумываем некоторую функцию <code>u</code>, например: <code>u = x*x + y*y + t</code>, придумываем значения констант <code>lambda</code>, <code>gamma</code>, <code>sigma</code>, и согласно верхнему уравнению можно вычислить функцию <code>f</code>, при которой дифференциальное уравнение превращается в тождество.</p>
<p>Для того, чтобы тестировать нашу программу на широком спектре функций, можно написать функцию, которая будет автоматически рассчитывать эту правую часть на основе вышеописанных функций для вычисления производных:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">typedef</span><span> std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">double</span><span>, </span><span style="color:#668f14;">double</span><span>, </span><span style="color:#668f14;">double</span><span>)&gt; </span><span style="color:#c23f31;">function_3d_t</span><span>;
</span><span>
</span><span style="color:#7f8989;">/** Все константы решаемого уравнения. */
</span><span style="color:#668f14;">struct </span><span style="color:#c23f31;">constants_t
</span><span>{
</span><span>	</span><span style="color:#668f14;">double</span><span> lambda; </span><span style="color:#7f8989;">/// Коэффициент внутри div
</span><span>	</span><span style="color:#668f14;">double</span><span> gamma;  </span><span style="color:#7f8989;">/// Коэффициент при u
</span><span>	</span><span style="color:#668f14;">double</span><span> sigma;  </span><span style="color:#7f8989;">/// Коэффициент при du/dt
</span><span>};
</span><span>
</span><span>function_3d_t </span><span style="color:#c23f31;">calc_right_part</span><span>(
</span><span>	</span><span style="color:#668f14;">const</span><span> function_3d_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">u</span><span>,
</span><span>	</span><span style="color:#668f14;">const</span><span> constants_t</span><span style="color:#72ab00;">&amp;</span><span> cs
</span><span>) {
</span><span>	</span><span style="color:#7f8989;">// f = -div(lambda * grad u) + gamma * u + sigma * du/dt
</span><span>	</span><span style="color:#72ab00;">return </span><span>[</span><span style="color:#72ab00;">=</span><span>](</span><span style="color:#668f14;">double</span><span> x, </span><span style="color:#668f14;">double</span><span> y, </span><span style="color:#668f14;">double</span><span> t) -&gt; </span><span style="color:#5597d6;">double </span><span>{
</span><span>		</span><span style="color:#72ab00;">using namespace</span><span> placeholders;
</span><span>		</span><span style="color:#668f14;">auto</span><span> ut </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">calc_first_derivative</span><span>(</span><span style="color:#5597d6;">bind</span><span>(u, x, y, _1));
</span><span>
</span><span>		</span><span style="color:#668f14;">auto</span><span> uxx </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">calc_second_derivative</span><span>(</span><span style="color:#5597d6;">bind</span><span>(u, _1, y, t));
</span><span>		</span><span style="color:#668f14;">auto</span><span> uyy </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">calc_second_derivative</span><span>(</span><span style="color:#5597d6;">bind</span><span>(u, x, _1, t));
</span><span>
</span><span>		</span><span style="color:#72ab00;">return -</span><span>cs.</span><span style="color:#5597d6;">lambda </span><span style="color:#72ab00;">* </span><span>(</span><span style="color:#5597d6;">uxx</span><span>(x) </span><span style="color:#72ab00;">+ </span><span style="color:#5597d6;">uyy</span><span>(y)) </span><span style="color:#72ab00;">+</span><span> cs.</span><span style="color:#5597d6;">gamma </span><span style="color:#72ab00;">* </span><span style="color:#5597d6;">u</span><span>(x, y, t) </span><span style="color:#72ab00;">+</span><span> cs.</span><span style="color:#5597d6;">sigma </span><span style="color:#72ab00;">* </span><span style="color:#5597d6;">ut</span><span>(t);
</span><span>	};
</span><span>}
</span></code></pre>
<p>Код взят опять же из <a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/fem.cpp#L304">репозитория по УМФ</a>.</p>
<p>Таким образом, мы получаем функцию <code>f</code> на основе известной нам функции <code>u</code>.</p>
<p>Это избавляет от лишней рутины ручного вычисления производных для функций при тестировании, автоматизируя этот процесс, также снижается вероятность ошибиться.</p>
<h1 id="obertka-dlia-podscheta-vyzovov-funktsii"><a class="anchor" href="#obertka-dlia-podscheta-vyzovov-funktsii">#</a>Обертка для подсчета вызовов функции</h1>
<p>Например, нам надо протестировать какой-то метод, находящий минимум заданной функции <code>f</code>. Надо узнать насколько он хороший путем определения сколько раз ему потребовалось обратиться к функции <code>f</code>, потому что обычно самой дорогой операцией считается именно вызов функции <code>f</code>. </p>
<p>Это можно сделать не вмешиваясь в код этого метода, явным образом выставляя <code>count++</code> при каждом вызове функции, послав вместо функции обёртку над ней:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">typedef</span><span> std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">const</span><span> Vector</span><span style="color:#72ab00;">&amp;</span><span>)&gt; </span><span style="color:#c23f31;">Function</span><span>;
</span><span>
</span><span>Function </span><span style="color:#c23f31;">setFunctionToCountCalls</span><span>(</span><span style="color:#668f14;">int</span><span style="color:#72ab00;">* </span><span style="color:#5597d6;">where</span><span>, </span><span style="color:#668f14;">const</span><span> Function</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>) {
</span><span>	(</span><span style="color:#72ab00;">*</span><span>where) </span><span style="color:#72ab00;">= </span><span style="color:#b3933a;">0</span><span>;
</span><span>	</span><span style="color:#72ab00;">return </span><span>[where, f](</span><span style="color:#668f14;">const</span><span> Vector</span><span style="color:#72ab00;">&amp;</span><span> v) -&gt; </span><span style="color:#5597d6;">double </span><span>{
</span><span>		(</span><span style="color:#72ab00;">*</span><span>where)</span><span style="color:#72ab00;">++</span><span>;
</span><span>		</span><span style="color:#72ab00;">return </span><span style="color:#5597d6;">f</span><span>(v);
</span><span>	};
</span><span>}
</span><span>
</span><span style="color:#668f14;">double </span><span style="color:#c23f31;">f</span><span>(</span><span style="color:#668f14;">const</span><span> Vector</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">v</span><span>) {
</span><span>	</span><span style="color:#7f8989;">// ...
</span><span>}
</span><span>
</span><span style="color:#668f14;">int</span><span> fCount </span><span style="color:#72ab00;">= </span><span style="color:#b3933a;">0</span><span>;
</span><span style="color:#668f14;">auto</span><span> result </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">optimize</span><span>(</span><span style="color:#7f8989;">/* ... */</span><span>, </span><span style="color:#5597d6;">setFunctionToCountCalls</span><span>(</span><span style="color:#72ab00;">&amp;</span><span style="color:#5597d6;">fCount</span><span>, f), </span><span style="color:#7f8989;">/* ... */</span><span>);
</span></code></pre>
<p>Взято из <a href="https://github.com/optozorax/optimization_methods/blob/feb65cda80b43145a58ada90b6de7c5ae8e777a4/2/methods.cpp#L268">2 лабораторной по МО</a>.</p>
<h1 id="zamer-vremeni"><a class="anchor" href="#zamer-vremeni">#</a>Замер времени</h1>
<p>У нас стоит задача замерить время работы какого-то кода. Можно поступить следующим образом:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#72ab00;">#include </span><span style="color:#d07711;">&lt;chrono&gt;
</span><span>
</span><span style="color:#72ab00;">using namespace</span><span> chrono;
</span><span style="color:#668f14;">auto</span><span> start </span><span style="color:#72ab00;">= </span><span>high_resolution_clock::</span><span style="color:#5597d6;">now</span><span>();
</span><span>
</span><span style="color:#7f8989;">// ...
</span><span style="color:#7f8989;">// main code
</span><span style="color:#7f8989;">// ...
</span><span>
</span><span style="color:#668f14;">auto</span><span> end </span><span style="color:#72ab00;">= </span><span>high_resolution_clock::</span><span style="color:#5597d6;">now</span><span>();
</span><span style="color:#668f14;">double</span><span> time </span><span style="color:#72ab00;">=</span><span> duration_cast&lt;microseconds&gt;(end </span><span style="color:#72ab00;">-</span><span> start).</span><span style="color:#5597d6;">count</span><span>();
</span></code></pre>
<p>Но это решение плохо тем, что нам постоянно надо копировать эти участки кода, и мы потенциально можем потерять начало или конец замера времени, поэтому можно воспользоваться концепцией RAII, и сделать это следующим красивым образом, передав в функцию замера времени лямбду кода, время которого будет замеряться:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#72ab00;">#include </span><span style="color:#d07711;">&lt;chrono&gt;
</span><span style="color:#72ab00;">#include </span><span style="color:#d07711;">&lt;functional&gt;
</span><span>
</span><span style="color:#7f8989;">/** Считает время выполнения функции f в микросекундах. */
</span><span style="color:#668f14;">inline double </span><span style="color:#c23f31;">calc_time_microseconds</span><span>(</span><span style="color:#668f14;">const</span><span> std::function&lt;</span><span style="color:#668f14;">void</span><span>(</span><span style="color:#668f14;">void</span><span>)&gt;</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>) {
</span><span>	</span><span style="color:#72ab00;">using namespace</span><span> std::chrono;
</span><span>	</span><span style="color:#668f14;">auto</span><span> start </span><span style="color:#72ab00;">= </span><span>high_resolution_clock::</span><span style="color:#5597d6;">now</span><span>();
</span><span>	</span><span style="color:#5597d6;">f</span><span>();
</span><span>	</span><span style="color:#668f14;">auto</span><span> end </span><span style="color:#72ab00;">= </span><span>high_resolution_clock::</span><span style="color:#5597d6;">now</span><span>();
</span><span>	</span><span style="color:#72ab00;">return </span><span style="color:#5597d6;">duration_cast</span><span>&lt;microseconds&gt;(end </span><span style="color:#72ab00;">-</span><span> start).</span><span style="color:#5597d6;">count</span><span>();;
</span><span>}
</span><span>
</span><span style="color:#668f14;">double</span><span> time </span><span style="color:#72ab00;">= </span><span style="color:#5597d6;">calc_time_microseconds</span><span>([</span><span style="color:#72ab00;">&amp;</span><span>](){
</span><span>	</span><span style="color:#7f8989;">// ...
</span><span>	</span><span style="color:#7f8989;">// main code
</span><span>	</span><span style="color:#7f8989;">// ...
</span><span>});
</span></code></pre>
<p>Притом мы не теряем локальные переменные благодаря использованию лямбд.</p>
<p>Код взят из <a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/lib.h#L24">курсовой по УМФ</a>.</p>
<h1 id="dvoinoi-integral"><a class="anchor" href="#dvoinoi-integral">#</a>Двойной интеграл</h1>
<p>Предположим, что у нас есть функция вычисления интеграла одномерной функции:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#72ab00;">#include </span><span style="color:#d07711;">&lt;functional&gt;
</span><span>
</span><span style="color:#668f14;">typedef</span><span> std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">double</span><span>)&gt; </span><span style="color:#c23f31;">function_1d_t</span><span>; 
</span><span>
</span><span style="color:#668f14;">double </span><span style="color:#c23f31;">calc_integral_gauss3</span><span>(
</span><span>	</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">a</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">b</span><span>, </span><span style="color:#668f14;">int </span><span style="color:#5597d6;">n</span><span>, </span><span style="color:#7f8989;">// n - количество внутренных узлов
</span><span>	</span><span style="color:#668f14;">const</span><span> function_1d_t</span><span style="color:#72ab00;">&amp;</span><span> f
</span><span>);
</span></code></pre>
<p>Тогда двойной интеграл двумерной функции можно вычислить следующим образом:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">double </span><span style="color:#c23f31;">calc_integral_gauss3</span><span>(
</span><span>	</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">ax</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">bx</span><span>, </span><span style="color:#668f14;">int </span><span style="color:#5597d6;">nx</span><span>,
</span><span>	</span><span style="color:#668f14;">double </span><span style="color:#5597d6;">ay</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">by</span><span>, </span><span style="color:#668f14;">int </span><span style="color:#5597d6;">ny</span><span>,
</span><span>	</span><span style="color:#668f14;">const</span><span> function_2d_t</span><span style="color:#72ab00;">&amp;</span><span> f
</span><span>) {
</span><span>	</span><span style="color:#72ab00;">return </span><span style="color:#5597d6;">calc_integral_gauss3</span><span>(ax, bx, nx, [ay, by, ny, f](</span><span style="color:#668f14;">double</span><span> x)-&gt;</span><span style="color:#5597d6;">double </span><span>{
</span><span>		</span><span style="color:#72ab00;">return </span><span style="color:#5597d6;">calc_integral_gauss3</span><span>(ay, by, ny, </span><span style="color:#5597d6;">bind</span><span>(f, x, _1));
</span><span>	});
</span><span>}
</span></code></pre>
<p>Код взят из <a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/fem.cpp#L269">курсовой по УМФ</a>.</p>
<h1 id="funktsii-testirovaniia"><a class="anchor" href="#funktsii-testirovaniia">#</a>Функции тестирования</h1>
<p>Представим, у нас есть множество методов, решающих одну задачу, но каждый по-разному, при этом интерфейс у них одинаковый. И стоит задача протестировать их все единым образом, построить таблицы. Это тоже можно красиво сделать с помощью <code>std::function</code>, написать прототип функции метода:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">typedef</span><span> std::function&lt;MethodResult(</span><span style="color:#7f8989;">/* Method args. */</span><span>)&gt; </span><span style="color:#c23f31;">Method</span><span>;
</span><span>
</span><span>MethodResult </span><span style="color:#c23f31;">method1</span><span>(</span><span style="color:#7f8989;">/* Method args. */</span><span>);
</span><span>MethodResult </span><span style="color:#c23f31;">method2</span><span>(</span><span style="color:#7f8989;">/* Method args. */</span><span>);
</span><span>MethodResult </span><span style="color:#c23f31;">method3</span><span>(</span><span style="color:#7f8989;">/* Method args. */</span><span>);
</span><span>MethodResult </span><span style="color:#c23f31;">method4</span><span>(</span><span style="color:#7f8989;">/* Method args. */</span><span>);
</span><span>MethodResult </span><span style="color:#c23f31;">method5</span><span>(</span><span style="color:#7f8989;">/* Method args. */</span><span>);
</span><span>
</span><span style="color:#668f14;">void </span><span style="color:#c23f31;">makeTableForMethod</span><span>(
</span><span>	</span><span style="color:#668f14;">const</span><span> Method</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">method</span><span>,
</span><span>	</span><span style="color:#668f14;">const</span><span> std::string</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">file</span><span>,
</span><span>	</span><span style="color:#7f8989;">/* Method args. */	
</span><span>) {
</span><span>	</span><span style="color:#7f8989;">// ...
</span><span>}
</span><span>
</span><span>std::vector&lt;pair&lt;Method, string&gt;&gt; methodsToTest </span><span style="color:#72ab00;">= </span><span>{
</span><span>	{method1, </span><span style="color:#d07711;">&quot;table1.txt&quot;</span><span>},	
</span><span>	{method2, </span><span style="color:#d07711;">&quot;table2.txt&quot;</span><span>},
</span><span>	{method3, </span><span style="color:#d07711;">&quot;table3.txt&quot;</span><span>},
</span><span>	{method4, </span><span style="color:#d07711;">&quot;table4.txt&quot;</span><span>},
</span><span>	{method5, </span><span style="color:#d07711;">&quot;table5.txt&quot;</span><span>},
</span><span>};
</span><span>
</span><span style="color:#72ab00;">for </span><span>(</span><span style="color:#668f14;">auto</span><span style="color:#72ab00;">&amp;</span><span> i </span><span style="color:#72ab00;">:</span><span> methodsToTest)
</span><span>	</span><span style="color:#5597d6;">makeTableForMethod</span><span>(i.</span><span style="color:#5597d6;">first</span><span>, i.</span><span style="color:#5597d6;">second</span><span>, </span><span style="color:#7f8989;">/* Method args. */</span><span>);
</span></code></pre>
<p>Некоторые люди делают это с помощью копипаста, но думаю не стоит вам объяснять чем плох копипаст по сравнению с этим подходом.</p>
<p>Код взят из <a href="https://github.com/optozorax/optimization_methods/blob/feb65cda80b43145a58ada90b6de7c5ae8e777a4/2/make_tables.cpp#L9">2 лабораторной по МО</a>.</p>
<h1 id="odnomernyi-poisk"><a class="anchor" href="#odnomernyi-poisk">#</a>Одномерный поиск</h1>
<p>В МО многомерные методы нахождения минимума функции используют одномерную функцию оптимизации. И было задание задавать различные методы одномерной оптимизации, чтобы протестировать их эффективность конкретно в этой среде. Ну раз так, то мы не будем в программе жестко задавать функцию одномерной оптимизации, а будем передавать её как аргумент функции многомерной оптимизации:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#668f14;">typedef</span><span> std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">const double</span><span style="color:#72ab00;">&amp;</span><span>)&gt; </span><span style="color:#c23f31;">OneDimensionFunction</span><span>;
</span><span style="color:#668f14;">typedef</span><span> std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">const</span><span> OneDimensionFunction</span><span style="color:#72ab00;">&amp;</span><span>, </span><span style="color:#668f14;">double</span><span>, </span><span style="color:#668f14;">double</span><span>, </span><span style="color:#668f14;">double</span><span>)&gt; </span><span style="color:#c23f31;">OneDimenshionExtremumFinder</span><span>;
</span><span>
</span><span style="color:#668f14;">double </span><span style="color:#c23f31;">oneDimensionOptimizator1</span><span>(</span><span style="color:#668f14;">const</span><span> OneDimensionFunction</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">a</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">b</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">eps</span><span>);
</span><span style="color:#668f14;">double </span><span style="color:#c23f31;">oneDimensionOptimizator2</span><span>(</span><span style="color:#668f14;">const</span><span> OneDimensionFunction</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">a</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">b</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">eps</span><span>);
</span><span style="color:#668f14;">double </span><span style="color:#c23f31;">oneDimensionOptimizator3</span><span>(</span><span style="color:#668f14;">const</span><span> OneDimensionFunction</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">a</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">b</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">eps</span><span>);
</span><span style="color:#668f14;">double </span><span style="color:#c23f31;">oneDimensionOptimizator4</span><span>(</span><span style="color:#668f14;">const</span><span> OneDimensionFunction</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">a</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">b</span><span>, </span><span style="color:#668f14;">double </span><span style="color:#5597d6;">eps</span><span>);
</span><span>
</span><span>
</span><span style="color:#668f14;">typedef</span><span> std::function&lt;</span><span style="color:#668f14;">double</span><span>(</span><span style="color:#668f14;">const</span><span> Vector</span><span style="color:#72ab00;">&amp;</span><span>)&gt; </span><span style="color:#c23f31;">Function</span><span>;
</span><span>
</span><span>MethodResult </span><span style="color:#c23f31;">multiDimenshionOptimize1</span><span>(
</span><span>	</span><span style="color:#668f14;">const</span><span> Function</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>, 
</span><span>	</span><span style="color:#668f14;">const</span><span> OneDimenshionExtremumFinder</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">argmin</span><span>, 
</span><span>	</span><span style="color:#668f14;">const</span><span> Vector</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">x0</span><span>, 
</span><span>	</span><span style="color:#668f14;">const double</span><span style="color:#72ab00;">&amp;</span><span> eps
</span><span>);
</span><span>
</span><span>MethodResult </span><span style="color:#c23f31;">multiDimenshionOptimize2</span><span>(
</span><span>	</span><span style="color:#668f14;">const</span><span> Function</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>, 
</span><span>	</span><span style="color:#668f14;">const</span><span> OneDimenshionExtremumFinder</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">argmin</span><span>, 
</span><span>	</span><span style="color:#668f14;">const</span><span> Vector</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">x0</span><span>, 
</span><span>	</span><span style="color:#668f14;">const double</span><span style="color:#72ab00;">&amp;</span><span> eps
</span><span>);
</span></code></pre>
<p>Код взят из <a href="https://github.com/optozorax/optimization_methods/blob/feb65cda80b43145a58ada90b6de7c5ae8e777a4/2/methods.h#L18">2 лабораторной по МО</a>.</p>
<h1 id="pattern-listener"><a class="anchor" href="#pattern-listener">#</a>Паттерн listener</h1>
<p>Иногда бывает так, что вам нужно выводить информацию о внутреннем состоянии метода, например, вы решаете задачу оптимизации, и вам надо на каждой итерации выводить текущее решение, значение градиента функции в этой точке итд, чтобы строить таблицу. Вместо того, чтобы делать это явно, можно передавать в функцию метода функцию <code>listener</code>, которая будет получать всё внутреннее состояние метода, и уже у себя внутри решать что с этим делать.</p>
<p>В одном случае она может выводить это на экран, в другом случае - в файл, а в третьем, когда нужная максимальная производительность - ничего не делать с этой информацией.</p>
<p>На самом деле я не использовал это на практике, а пример этого паттерна взял из библиотеки <a href="https://github.com/optozorax/differential-evolution/blob/9cfefc0b36ed3bf4ca6c37d786244d56c0b3b2ba/de_test/tutorial.cpp#L71">дифференциальной эволюции</a>.</p>
<p>Там же можно увидеть <strong>паттерн termination strategy</strong>, при помощи которого можно передавать в метод функцию, которая будет решать когда завершать метод. Но в рамках нашей учебной программы это излишная абстракция, и различные стратегии завершения метода никогда не применятся.</p>
<h1 id="inkapsuliruem-s-pomoshch-iu-std-function"><a class="anchor" href="#inkapsuliruem-s-pomoshch-iu-std-function">#</a>Инкапсулируем с помощью <code>std::function</code></h1>
<p>В УМФ у нас есть задача получить конечно-элементную аппроксимацию функции на основе правой части дифференциального уравнения и сетки конечных элементов. Учитывая эту информацию, решатель МКЭ может выглядеть следующим образом:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>vector_t </span><span style="color:#c23f31;">solve_differential_equation</span><span>(
</span><span>	</span><span style="color:#668f14;">const</span><span> function_3d_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>,
</span><span>	</span><span style="color:#668f14;">const</span><span> grid_t</span><span style="color:#72ab00;">&amp;</span><span> grid
</span><span>);
</span></code></pre>
<p>Возвращается вектор, потому что мы находим только аппроксимацию весов <code>q</code>, именно они и возвращаются в методе.</p>
<p>Но при решении МКЭ мы не можем игнорировать ту вещь, что нам нужно выставлять краевые условия. Краевые условия - это известные нам значения функции на краях области. Не имея краевых значений, невозможно решить задачу, она просто не сойдется.</p>
<p>Поэтому мы должны каким-то образом внутри функции решения дифференциального уравнения выставлять краевые условия.</p>
<p>В нашем курсе УМФ мы не решаем реальные задачи, а лишь исследуем насколько хорошо метод справляется с известными нам функциями <code>u</code>, поэтому может появиться соблазн написать следующим образом:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>vector_t </span><span style="color:#c23f31;">solve_differential_equation</span><span>(
</span><span>	</span><span style="color:#668f14;">const</span><span> function_3d_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>,
</span><span>	</span><span style="color:#668f14;">const</span><span> grid_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">grid</span><span>,
</span><span>	</span><span style="color:#668f14;">const</span><span> function_3d_t</span><span style="color:#72ab00;">&amp;</span><span> true_function_u
</span><span>) {
</span><span>	</span><span style="color:#7f8989;">// doing smth
</span><span>	</span><span style="color:#7f8989;">// выставляем краевые условия с помощью функции u по краям области
</span><span>	</span><span style="color:#7f8989;">// делаем что-то дальше
</span><span>}
</span></code></pre>
<p>Но это ужасный стиль! Зачем нам находить значение функции при помощи численных методов, которую мы уже знаем? Это выглядит как бред, поэтому более красивым может быть передавать <strong>функцию, которая выставляет краевые условия</strong>:</p>
<pre data-lang="c++" style="background-color:#f5f5f5;color:#1f1f1f;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>vector_t </span><span style="color:#c23f31;">solve_differential_equation</span><span>(
</span><span>	</span><span style="color:#668f14;">const</span><span> function_3d_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">f</span><span>,
</span><span>	</span><span style="color:#668f14;">const</span><span> grid_t</span><span style="color:#72ab00;">&amp; </span><span style="color:#5597d6;">grid</span><span>, 
</span><span>	</span><span style="color:#668f14;">const</span><span> boundary_setter_function_t</span><span style="color:#72ab00;">&amp;</span><span> set_boundary_conditions
</span><span>) {
</span><span>	</span><span style="color:#7f8989;">// doing smth
</span><span>	</span><span style="color:#5597d6;">set_boundary_conditions</span><span>(</span><span style="color:#7f8989;">/* ... */</span><span>);
</span><span>	</span><span style="color:#7f8989;">// делаем что-то дальше
</span><span>}
</span></code></pre>
<p>Это очень красивое решение, которое может быть применено при решении реальных задач, если мы реально не знаем истинную функцию, но знаем значения краевых условий. Это значительно повышает абстрактность кода, позволяет его использовать в других проектах.</p>
<p>Так как вы можете использовать это на практике, более подробно смотрите код из курсовой по УМФ:</p>
<ul>
<li><a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/fem.h#L146">Прототип функции выставления краевых условий.</a></li>
<li><a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/fem.h#L149">Сама функция выставления краевых условий на основе известной нам функции u.</a></li>
<li><a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/fem.h#L159">Функция решения МКЭ.</a></li>
<li><a href="https://github.com/optozorax/labs_emf/blob/60b62fb5746aa83e3c52a802d5da1741950b6292/coursework/main.cpp#L32">Пример использования.</a></li>
</ul>
<h1 id="zakliuchenie"><a class="anchor" href="#zakliuchenie">#</a>Заключение</h1>
<p>Было показано каким образом <code>std::function</code> позволит вам избавиться от лишнего копипаста и инкапсулировать код и данные и в принципе сделать код намного более абстрактным и красивым. Если вы придумали ещё одно интересное применение <code>std::function</code>, то пишите в комментариях!</p>

</div>
</article>

  </section>
  

</td><td>
<!-- TOC -->
<div class="side-button" onclick="toggle_toc()">❰</div>
<nav class="section-nav">
 <h2>Содержание</h2>
 <ul class="first">
 
 
  <li>
   <a href="#stat-ia-ob-ispol-zovanii-std-function">Статья об использовании std::function</a>
   
  </li>
 
 
  <li>
   <a href="#vvedenie">Введение</a>
   
  </li>
 
 
  <li>
   <a href="#chislennoe-vychislenie-proizvodnoi">Численное вычисление производной</a>
   
  </li>
 
 
  <li>
   <a href="#primer-ispol-zovaniia-std-bind">Пример использования std::bind</a>
   
  </li>
 
 
  <li>
   <a href="#avtomaticheskii-raschet-pravoi-chasti">Автоматический расчет правой части</a>
   
  </li>
 
 
  <li>
   <a href="#obertka-dlia-podscheta-vyzovov-funktsii">Обертка для подсчета вызовов функции</a>
   
  </li>
 
 
  <li>
   <a href="#zamer-vremeni">Замер времени</a>
   
  </li>
 
 
  <li>
   <a href="#dvoinoi-integral">Двойной интеграл</a>
   
  </li>
 
 
  <li>
   <a href="#funktsii-testirovaniia">Функции тестирования</a>
   
  </li>
 
 
  <li>
   <a href="#odnomernyi-poisk">Одномерный поиск</a>
   
  </li>
 
 
  <li>
   <a href="#pattern-listener">Паттерн listener</a>
   
  </li>
 
 
  <li>
   <a href="#inkapsuliruem-s-pomoshch-iu-std-function">Инкапсулируем с помощью std::function</a>
   
  </li>
 
 
  <li>
   <a href="#zakliuchenie">Заключение</a>
   
  </li>
 
 </ul>
</nav>
</td></tr></table>



<!-- comments -->
<hr class="enabled-on-phone">

<table class="toc-aligmenter"><tr><td>

<section class="section second-section">
Если вам нравится что я делаю, то подписывайтесь на меня в <a href="https://t.me/optozorax_dev">Telegram</a> и <a href="https://www.youtube.com/c/optozorax">YouTube</a>.
</section>

</td><td>
</td></tr></table>




<!-- comments -->
<hr class="enabled-on-phone">

<table class="toc-aligmenter"><tr><td>

<section class="comments section second-section">

<script src="https://utteranc.es/client.js"
        repo="optozorax/optozorax.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</section>

</td><td>
</td></tr></table>





  <hr class="enabled-on-phone">

  

<table class="toc-aligmenter"><tr><td>


  <footer class="site-footer section second-section">
  
    <center>
    <div style="margin-bottom: 10px;">© Шепрут Илья. Лицензия: <a href="https://creativecommons.org/licenses/by/3.0/deed.ru">CC-BY</a>.</div>
    <table style="border: 0px; display: contents;">
    <tr><td style="border: 0px; padding: 0.2rem;">
    <!-- SVG icons from https://iconmonstr.com -->

    
<span class="my-span-icon">
  <a 
    href="https:&#x2F;&#x2F;github.com&#x2F;optozorax" 
    aria-label="optozorax's GitHub" 
    title="optozorax's GitHub">
    <img 
      class="my-svg-icon" 
      src="/ico/github.svg" 
      width="24" 
      height="24"
      alt="optozorax's GitHub">
  </a>
</span>


    
<span class="my-span-icon">
  <a 
    href="https:&#x2F;&#x2F;t.me&#x2F;optozorax_dev" 
    aria-label="optozorax's Telegram channel" 
    title="optozorax's Telegram channel">
    <img 
      class="my-svg-icon" 
      src="/ico/tg.svg" 
      width="24" 
      height="24"
      alt="optozorax's Telegram channel">
  </a>
</span>


    
<span class="my-span-icon">
  <a 
    href="https:&#x2F;&#x2F;www.youtube.com&#x2F;c&#x2F;optozorax" 
    aria-label="optozorax's YouTube channel" 
    title="optozorax's YouTube channel">
    <img 
      class="my-svg-icon" 
      src="/ico/youtube.svg" 
      width="24" 
      height="24"
      alt="optozorax's YouTube channel">
  </a>
</span>


    
<span class="my-span-icon">
  <a 
    href="&#x2F;atom.xml" 
    aria-label="optozorax's Atom Feed" 
    title="optozorax's Atom Feed">
    <img 
      class="my-svg-icon" 
      src="/ico/rss.svg" 
      width="24" 
      height="24"
      alt="optozorax's Atom Feed">
  </a>
</span>


    
<span class="my-span-icon">
  <a 
    href="mailto:optozorax@gmail.com" 
    aria-label="optozorax's email" 
    title="optozorax's email">
    <img 
      class="my-svg-icon" 
      src="/ico/contact.svg" 
      width="24" 
      height="24"
      alt="optozorax's email">
  </a>
</span>


    </td><td style="border: 0px; padding: 0.2rem;">
    
    <!-- Yandex.Metrika informer -->
    <a href="https://metrika.yandex.ru/stat/?id=53392057&amp;from=informer" target="_blank" rel="nofollkw"><img src="https://informer.yandex.ru/informer/53392057/1_0_35B977FF_159957FF_1_pageviews" style="width:80px; height:15px; border:0; border-radius: 0px; margin-top: -4px; max-height: 100%; max-width: 100%;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры)" class="ym-advanced-informer" data-cid="53392057" data-lang="ru" /></a> 
    <!-- /Yandex.Metrika informer -->
    

    </td></tr>
    </table>
    <div class="small-info">
      Сделано с помощью <a href="https://www.getzola.org/">Zola</a> | База темы <a href="https://github.com/lorepirri/cayman-blog">Cayman Blog</a> | <a href="https://github.com/optozorax/blog_zola">Исходники сайта</a>
    </div>
    </center>
  
  </footer>
  

</td><td>
</td></tr></table>



  
</body>
</html>